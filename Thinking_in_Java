引用没有指向后就被回收了
static字段只会有一个，多个引用只会指向那一个，要是连类都是是静态的话就没有引用了，直接用类名调用它。即使类不是静态也可以通过类名引用静态字段。
java.lang默认导入
javadoc还不会用。
==比的事这个地址下存的东西，但实际上只有基础类型才直接存值；.equal才会比这个地址存的引用引用的内容。
逻辑表达的短路：逻辑表达式已经能得出结论时，后面的不再计算。
跳过了位操作符
构造器无返回值，但new表达式会返回一个新建对象的引用
根据变量区分重载函数
this相当于上一个对象引用被传进所调用的方法了。
this连续两次构造的关键点在于参数数量是在不断减少的所以默认构造器只会最后才出现。
static的另一层含义：static静态方法是没有this的，所以它不能调用非静态方法（因为非静态方法要默认传一个this，代替当前实例对象的引用，而static方法没有this）当然如果手动传一个实例对象引用就可以了。
垃圾回收机制的finalize()方法。
finalize()方法似乎是在对象被回收时被调用的，还可以加判断来判定回收条件是否符合。
java的垃圾回收器使得它在堆中不必去找哪些空闲内存块，它会在回收空间的同时使堆中已经存在的对象紧密排列，实现高速且有无限空间分配的堆模型，速度接近堆栈上分配空间的速度。
引用离开作用域或被置为null，对象的“引用计数”减1；但实际上是从堆栈和静态存储区之中的引用开始遍历找出所有“活”的对象。先从这个引用开始找到对应的实例对象，然而找到这个对象包含的其它的所有引用，不断重复，直到所有网络都被访问为止。“死”的对象不访问。
自适应垃圾回收技术的一种做法是停止_复制：先暂停程序的运行，把活对象从当前堆复制到另一个堆，没有被复制的都是垃圾。同时新堆被复制后是一个接一个紧凑排列的。
自适应垃圾回收技术的另一种工作模式是标记_清扫：同样从堆栈和静态存储区中出发，但只给存活对象设置标记，不回收。全部标记完成后，将没被标记的释放掉，不复制。因此剩下的空间不连续。
自适应的分块排列以及每个块有代数，引用就加1，废弃块会被放入新对象。
即时编译器技术（Just-In-Time,JIT）弄成本地机器码，代码被执行的次数越多，它的速度就越快。类加载器在成功加载某个类之后，会把得到的 java.lang.Class类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。
类的字段会比类先初始化（比该类的构造函数还先调用）
可变参数列表：Object... obj，这里可以接受多个不限类型的参数。
public static void main(String[] args)是每个class的执行入口，没有这个入口就无法方便地单元测试。同时java xxx就相当于xxx.main()了，即使xxx不是public也可以。
类独立于文件，依靠Package路径的java命令调用！

正在播放 《你是魔鬼吗》 ━━━━━━─────── 3:47 ⇆ ◁ ❚❚ ▷ ↻

private修饰的属性或方法为该类所特有，在任何其他类中都不能直接访问；
default修饰的属性或方法具有包访问特性，同一个包中的其他类可以访问；
protected修饰的属性或方法在同一个中的其他类可以访问，同时对于不在同一个包中的子类中也可以访问；
public修饰的属性或方法外部类中都可以直接访问。
当子类继承父类，子类可以继承父类中具有访问控制权限的属性和方法（一般来说是非private修饰的），对于private修饰的父类所特有的属性和方法，子类是不继承过来的。
当子类需要改变继承过来的方法时，也就是常说的重写父类的方法。一旦重写后，父类的此方法对子类来说表现为隐藏。以后子类的对象调用此方法时，都是调用子类重写后
的方法，但子类对象中想调用父类原来的此方法时，可以通过如下两种方式：
1.将子类对象类型强制转化为父类类型，进行调用；
2.通过super调用。
同样的，如果在子类中定义父类中相同名称的属性时，父类属性在子类中表现为隐藏

因此public ,protected, private区别就只有类与类之间的关系了。类内，类继承间，类与类外。文件只是载体，具体通过本身的类名与package路径组成的全名加以区分。
继承：从最初父类开始的构造，可用它们的public/protected方法与字段。
super(xxx)方法一般用于父类只有含参构造器而没有实现默认构造器时在子类构造器中第一行使用。
final字段避免被修改，final方法避免继承中被重写或重载，final类避免被继承。
通过上转型和后期的动态绑定来实现多态，先实例化一个对象赋给基类引用（动态绑定），覆盖方法后会根据相应的类型来调用相应的方法(表面上表现为使用基类引用去表示子类实例对象去调用方法，基类方法根据子类的类型执行不同的操作)。
字段是基类的，方法可以动态绑定至导出类所覆盖的方法上。

正在播放 《你是魔鬼吗》 ━━━━━━─────── 3:47 ⇆ ◁ ❚❚ ▷ ↻

容器的如果不带尖括号说明类型就直接是Object类型了，下次取用要强制转换。
容器本身就是泛型
Collection<class>
Collections.addAll()很快，首先方式
.iterator()返回一个迭代器对象，用Iterator<class> 引用接住它。
异常被抛出后将在别的地方被处理
System.out.print()与System.out.format()用法一样，形式上与C语言的printf()相同。
Java正则表达式：“？”表示上一个是可能有，“+”表示上一个是可能有很多。
多态与容器组合测试我还不会？
List容器将对象作为Object对象存储吗，取出时再转回去吗。
任务作为进程在自己的地址空间中运行。
Thread构造器的start方法调用后将开启一个新线程运行任务，之后start方法立即返回，继续本线程的执行。
Thread构造器的yield方法声明可以切换给其他任务了。
多线程的异常不能跨线程传回去，必须在此线程内处理。
start之前(Thread).setDaemon(true)可置为后台线程。后台线程无法阻止程序关闭，必须由非后台线程（比如main()）来维持程序的持续运转。
ExecutorService的shutdown方法用于终止线程（如果不中止它就一直在运行，就停不下来了。）
一旦被继承，子类就可以自己调用所有父类的非私有变量及方法了。（比如继承自Thread类的子类可以变得跟Thread类实例对象一样用自己的实例对象调用.start()方法实现多线程。）
异步方式实现多线程：ExecutorService创建一个实例对象接住Executors的线程池方法，之后可用这个实例对象调用execute()方法执行异步方式的多线程，最后要使用exec.shutdown();否则停不下来。它对封装好的多线程体没有特殊要求，与调用.start()方法一样，但比start()方法更加安全。


正在播放 《你是魔鬼吗》 ━━━━━━─────── 3:47 ⇆ ◁ ❚❚ ▷ ↻


StringBuffer的.append(str)方法代替String的“+”连接，速度更快一些。
String str = new String("1")创建于堆中，intern()方法会建在字符串常量池里有个记录，而String str1 = "1"优先于字符串常量池中查找对象并返回。内存空间地址。如果常量池中没有，就在堆中生成对象，同时在常量池中生成一个引用。字符串常量池只存储引用，不存储内容。那么比如String a = "Hello Wolrd"中的Hello Wolrd是保存在堆中的对象里。
栈里的实例对象引用或者字符引用指向堆中的对象或者常量池中的常量



子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的一些属性或方法。
类的初始化不同于类实例对象的初始化，类的初始化只有一次，当对同一个类new多个对象时，类属性和类初始化块只初始化一次。类属性和代码块顺序决定了初始化的顺序（代码块是就仅被｛｝包含的代码块，但这句话是什么意思？与类属性在一起的明显是静态(static)代码块，而且静态(static)代码块必然在类属性的后面；并且类在通过new创建实例对象时必然是先调用代码块再调用构造器），若类存在父类，则首先初始化父类的类属性和类初始化块，一直上溯到Object类最先执行。————到这里，这个类就算是在JVM里装载完成了。接下来就在main()方法入口里面等着用new来调用创建实例对象了。在new创建对象时，首先对对象属性和初始化块分配内存，并执行默认初始化（这里应该注意：即使实现并调用了含参构造器，也会默认先调用无参的默认构造器！）。如果存在父类，则先为父类对象属和初始化块先分配内存并执行初始化。然后执行父类构造器中的初始化程序，接着才开始对子类的对象属性和初始化块执行初始化。
(下面的我还有点不熟)
4.继承中的this和super：
构造器中的this表示当前正在初始化的对象引用，方法中的this表示当前正在调用此方法的对象引用。this具体用法表现在以下几个方面：
1.当具多个重载的构造器时，且一个构造器需要调用另外一个构造器，在其第一行使用this（param）形式调用，且只能在第一行；
2.当对象中一个方法需要调用本对象中其他方法时，使用this作为主调，也可以不写，实际上默认就是this作为主调；
3.当对象属性和方法中的局部变量名称相同时，在该方法中需要显式的使用this作为主调，以表示对象的属性，若不存在此问题，可以不显式的写this。（比如下面的例子）
int param;
function abc(string param){
    this.param=param
}

其实，其牵涉到的一个问题就是变量的查找规则：先局部变量 => 当前类中定义的变量 => 其父类中定义的可以被子类继承的变量 => 父类...
super表示调用父类中相应的属性和方法。在方法中，若需要调用父类的方法时，也一定要写在第一行
(下面的我还有点不熟)
5. 继承与组合：
从单纯的实现效果上看，继承和组合都能达到同样的目的。并且都是实现代码复用的有效方式。
但在一般性的概念层次中，两者具有较为明显的差别。
继承表现为一般——特殊的关系，子类是一个特殊的父类，是is-a的关系。父类具有所有子类的一般特性。
组合表现为整体——部分关系，即has-a关系。在组合中，通过将“部分”单独抽取出来，形成自己的类定义，并且在“整体”
这个类定义中，将部分定义为其中的一个属性，并通过get和set方法，以此可以调用“部分”类中的属性和方法。


这是试验理解：
1、每一个类的静态(static)代码块都只会在往JVM中装载时执行且只执行一次！
2、声明一个继承自父类的子类时，先把父类的构造代码块及构造方法初始化然后初始化子类的构造代码块和构造方法。
3、构造代码块先于构造方法！

正在播放 《你是魔鬼吗》 ━━━━━━─────── 3:47 ⇆ ◁ ❚❚ ▷ ↻

YGC ：对新生代堆进行gc。频率比较高，因为大部分对象的存活寿命较短，在新生代里被回收。性能耗费较小。
FGC ：全堆范围的gc。默认堆空间使用到达80%(可调整)的时候会触发fgc。以我们生产环境为例，一般比较少会触发fgc，有时10天或一周左右会有一次。
什么时候执行YGC和FGC:
1、a.eden空间不足,执行 young gc
2、b.old空间不足，perm空间不足，调用方法System.gc() ，ygc时的悲观策略, dump live的内存信息时(jmap –dump:live)，都会执行full gc

正在播放 《你是魔鬼吗》 ━━━━━━─────── 3:47 ⇆ ◁ ❚❚ ▷ ↻

long l_starttime = System.nanoTime();
long l_endtime = System.nanoTime();
System.out.println("运行时间为:" + (l_endtime - l_starttime) + "us");

正在播放 《你是魔鬼吗》 ━━━━━━─────── 3:47 ⇆ ◁ ❚❚ ▷ ↻

  排序a数组：
	public static void sort(Object[] a)
  a数组二分找key，先排序：
  	public static int binarySearch(Object[] a, Object key)

    Arrays.sort(t1.nn_exp);
    System.out.println(Arrays.binarySearch(t1.nn_exp, 44));

    用val填a数组：
    	public static void fill(int[] a, int val)
        完全相同比较数组：
        	public static boolean equals(Object[] a, Object[] a2)

正在播放 《你是魔鬼吗》 ━━━━━━─────── 3:47 ⇆ ◁ ❚❚ ▷ ↻

List<Integer> list_n = new ArrayList<>();

list_n.add(1);
list_n.add(2);

System.out.println(list_n);
list_n.clear();
System.out.println(list_n);
list_n.add(8);
list_n.add(8);
System.out.println(list_n);


正在播放 《你是魔鬼吗》 ━━━━━━─────── 3:47 ⇆ ◁ ❚❚ ▷ ↻
