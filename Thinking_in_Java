引用没有指向后就被回收了
static字段只会有一个，多个引用只会指向那一个，要是连类都是是静态的话就没有引用了，直接用类名调用它。即使类不是静态也可以通过类名引用静态字段。
java.lang默认导入
javadoc还不会用。
==比的事这个地址下存的东西，但实际上只有基础类型才直接存值；.equal才会比这个地址存的引用引用的内容。
逻辑表达的短路：逻辑表达式已经能得出结论时，后面的不再计算。
跳过了位操作符
构造器无返回值，但new表达式会返回一个新建对象的引用
根据变量区分重载函数
this相当于上一个对象引用被传进所调用的方法了。
this连续两次构造的关键点在于参数数量是在不断减少的所以默认构造器只会最后才出现。
static的另一层含义：static静态方法是没有this的，所以它不能调用非静态方法（因为非静态方法要默认传一个this，代替当前实例对象的引用，而static方法没有this）当然如果手动传一个实例对象引用就可以了。
垃圾回收机制的finalize()方法。
finalize()方法似乎是在对象被回收时被调用的，还可以加判断来判定回收条件是否符合。
java的垃圾回收器使得它在堆中不必去找哪些空闲内存块，它会在回收空间的同时使堆中已经存在的对象紧密排列，实现高速且有无限空间分配的堆模型，速度接近堆栈上分配空间的速度。
引用离开作用域或被置为null，对象的“引用计数”减1；但实际上是从堆栈和静态存储区之中的引用开始遍历找出所有“活”的对象。先从这个引用开始找到对应的实例对象，然而找到这个对象包含的其它的所有引用，不断重复，直到所有网络都被访问为止。“死”的对象不访问。
自适应垃圾回收技术的一种做法是停止_复制：先暂停程序的运行，把活对象从当前堆复制到另一个堆，没有被复制的都是垃圾。同时新堆被复制后是一个接一个紧凑排列的。
自适应垃圾回收技术的另一种工作模式是标记_清扫：同样从堆栈和静态存储区中出发，但只给存活对象设置标记，不回收。全部标记完成后，将没被标记的释放掉，不复制。因此剩下的空间不连续。
自适应的分块排列以及每个块有代数，引用就加1，废弃块会被放入新对象。
即时编译器技术（Just-In-Time,JIT）弄成本地机器码，代码被执行的次数越多，它的速度就越快。类加载器在成功加载某个类之后，会把得到的 java.lang.Class类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。
类的字段会比类先初始化（比该类的构造函数还先调用）
可变参数列表：Object... obj，这里可以接受多个不限类型的参数。
public static void main(String[] args)是每个class的执行入口，没有这个入口就无法方便地单元测试。同时java xxx就相当于xxx.main()了，即使xxx不是public也可以。
类独立于文件，依靠Package路径的java命令调用！

正在播放 《你是魔鬼吗》 ━━━━━━─────── 3:47 