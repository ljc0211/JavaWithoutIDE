————————网络：
TCP：面向连接，可靠交付，流量控制，拥塞控制，全双工通信，只能为点对点（一对一）->好比下载文件的时候；将应用层来的报文视为字节流，组织成大小不等的数据块（意思是会合并或拆分？）；TCP首部有个序号，为上一字节流编号+上一字节流长度，还有一个确认号，应该与下一字节流的序号相同，否则就出错了；数据偏移指导数据部分离报文段起始处的距离，即首部的长度；（确认ACK）ACK=1时确认号字段才有效，规定建立连接后必须为1；（同步SYN）建立连接时用于同步（例：TCP请求连接时发送的是SYN=1,ACK=0，同意后响应SYN=1,ACK=1）；（终止FIN）释放连接（FIN=1表示要求释放连接）；（窗口）由接收方确定，因接收方数据缓存空间有限；

第三次握手作用：防止之前可能滞留在网络中但已经失效的请求，在发出新请求甚至是已经连接后对服务器对之前滞留的请求的回应不进行第三次握手回复。即第三次握手后的请求才是有效的。

四次挥手的原因：客户端发出FIN=1报文要中止，同时不再对服务器发送数据。但服务器需要一段时间来关闭应用程序，此时还在向客户端发送数据（这就是TCP半关闭状态，服务端处于CLOSE_WAIT状态）。传送完毕后再发一个FIN=1，客户端收到后发一个确认ACK=1，进入TIME_WAIT状态，此时最多等待2MSL时间（这是为了确保服务端收到这个ACK=1，以免再发一个FIN=1；同是也是为了令本连接所有报文从网络中消失，以免下一个新连接出现旧报文。）

TCP滑动窗口：窗口大小由接收方决定；左边完成就往右移；接收方只对按序到达的最后一个字节进行确认（如已到达31，34，35，只确认31，这样可同时确认了1~30.）

TCP流量控制：控制发送方速度，确保接收方来得及。通过TCP滑动窗口实现，如果接收方把窗口字段设置为0，那发送方就无法发送数据了。

TCP拥塞控制：拥塞导致分组丢失。如果继续重传会加重拥塞。此时应类似TCP流量控制，但目的不是为了接收方来得及接收，而是为了降低整个网络的拥塞程度。

UDP：无连接，尽最大可能交付，无拥塞控制一对一（多），多对一（多）均可；将应用层来的报文不合并也不拆分，直接加UDP首部；UDP数据部分前面的UDP首部包含长度检验和与源，目的端口；UDP首部前面包含了一个伪首部，分别为源，目的IP地址，这个伪首部是计算检验和临时加的。

————————MySQL：
客户端启动：mysql -h主机名  -u用户名 -p密码
客户端进程向服务器进程发送请求并得到回复的过程本质上是一个进程间通信的过程，MySQL支持下边三种客户端进程和服务器进程的通信方式：
	（TCP/IP）在网络中的其他进程可以通过IP地址 + 端口号的方式来与服务器进程连接，这样进程之间就可以通过网络进行通信；MySQL服务器会默认监听3306端口（自定义该数据库实例监听的端口号：mysqld -P3307）（比如我们现在已经在本机启动了服务器进程，监听的端口号为3307，那我们启动客户端程序时可以这样写：mysql -h127.0.0.1 -uroot -P3307 -p）；
	（Windows本地）命名管道和共享内存；
	（类Unix本地）Unix域套接字文件

服务器程序处理来自客户端的查询请求大致需要经过三个部分，分别是连接管理、解析与优化、存储引擎。
	连接管理：服务器进程监听端口，每有一个客户端进程连接到服务器进程时服务器进程就创建一个线程与客户端进程交互。客户端退出时断开连接，但该线程不会被销毁，而是缓存起来等着分配给新客户端（可以节省开销，不频繁创建和销毁线程）；
	解析与优化：几个比较重要的部分分别是查询缓存、语法解析和查询优化
		查询缓存：把刚刚处理过的查询请求和结果缓存起来，如果下一次有一模一样的请求过来，直接从缓存中查找结果就好了，就不用再傻呵呵的去底层的表中查找了。这个查询缓存可以在不同客户端之间共享，也就是说如果客户端A刚刚查询了一个语句，而客户端B之后发送了同样的查询请求，那么客户端B的这次查询就可以直接使用查询缓存中的数据。当然，MySQL服务器并没有人聪明，如果两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。另外，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，比如函数NOW，每次调用都会产生最新的当前时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询的结果就是错误的！不过既然是缓存，那就有它缓存失效的时候。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了INSERT、 UPDATE、DELETE、TRUNCATE TABLE、ALTER TABLE、DROP TABLE或 DROP DATABASE语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！（小贴士： 虽然查询缓存有时可以提升系统性能，但也不得不因维护这块缓存而造成一些开销，比如每次都要去查询缓存中检索，查询请求处理完需要更新查询缓存，维护该查询缓存对应的内存区域。从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除。）
		语法解析：如果查询缓存没有命中，接下来就需要进入正式的查询阶段了。先判断发来的文本语法正误，然后提取要用的（小贴士： 这个从指定的文本中提取出我们需要的信息本质上算是一个编译过程，涉及词法解析、语法分析、语义分析等阶段，这些问题不属于我们讨论的范畴，大家只要了解在处理请求的过程中需要这个步骤就好了。）；
		查询优化：语法解析之后，服务器程序优化一下用更高效的方式去执行（得到相同结果）；
		存储引擎：去访问操作真实的数据表，存储引擎封装了数据存储与提取的操作（小贴士： 为什么叫`引擎`呢？因为这个名字更拉风～ 其实这个存储引擎以前叫做`表处理器`，后来可能人们觉得太土，就改成了`存储引擎`的叫法，它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作。）；

MySQL server的功能：连接管理、查询缓存、语法解析、查询优化这些并不涉及真实数据存储的功能；
存储引擎的功能：真实存取数据的功能（各种不同的存储引擎向上边的MySQL server层提供统一的调用接口（也就是存储引擎API），包含了几十个底层函数，像"读取索引第一条内容"、"读取索引下一条内容"、"插入记录"等等。）；

创建表时指定存储引擎：（默认的存储引擎InnoDB）
	CREATE TABLE 表名(
	    建表语句;
	) ENGINE = 存储引擎名称;

	比如我们想创建一个存储引擎为MyISAM的表可以这么写：

	mysql> CREATE TABLE engine_demo_table(
	    ->     i int
	    -> ) ENGINE = MyISAM;
	Query OK, 0 rows affected (0.02 sec)
	
	mysql>

修改表的存储引擎：
	如果表已经建好了，我们也可以使用下边这个语句来修改表的存储引擎：
	
	ALTER TABLE 表名 ENGINE = 存储引擎名称;
	比如我们修改一下engine_demo_table表的存储引擎：
	
	mysql> ALTER TABLE engine_demo_table ENGINE = InnoDB;
	Query OK, 0 rows affected (0.05 sec)
	Records: 0  Duplicates: 0  Warnings: 0
	
	mysql>
	这时我们再查看一下engine_demo_table的表结构：
	
	mysql> SHOW CREATE TABLE engine_demo_table\G
	*************************** 1. row ***************************
	       Table: engine_demo_table
	Create Table: CREATE TABLE `engine_demo_table` (
	  `i` int(11) DEFAULT NULL
	) ENGINE=InnoDB DEFAULT CHARSET=utf8
	1 row in set (0.01 sec)
	
	mysql>
	可以看到该表的存储引擎已经改为InnoDB了。

（数据库级别）在创建和修改数据库的时候可以指定该数据库的字符集和比较规则，具体语法如下：

	CREATE DATABASE 数据库名
	    [[DEFAULT] CHARACTER SET 字符集名称]
	    [[DEFAULT] COLLATE 比较规则名称];
	
	ALTER DATABASE 数据库名
	    [[DEFAULT] CHARACTER SET 字符集名称]
	    [[DEFAULT] COLLATE 比较规则名称];

（表级别）我们也可以在创建和修改表的时候指定表的字符集和比较规则，语法如下：

        CREATE TABLE 表名 (列的信息)
            [[DEFAULT] CHARACTER SET 字符集名称]
            [COLLATE 比较规则名称]]

        ALTER TABLE 表名
            [[DEFAULT] CHARACTER SET 字符集名称]
            [COLLATE 比较规则名称]

InnoDB采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16 KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。
	

当数据页中存在多条被删除掉的记录时，这些记录的next_record属性将会把这些被删除掉的记录组成一个垃圾链表，以备之后重用这部分存储空间。

不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到B+树这个数据结构中了，所以我们也称这些数据页为节点。从图中可以看出来，我们的实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为叶子节点或叶节点，其余用来存放目录项的节点称为非叶子节点或者内节点，其中B+树最上边的那个节点也称为根节点。

为什么我们还需要一次回表操作呢？直接把完整的用户记录放到叶子节点不就好了么？你说的对，如果把完整的用户记录放到叶子节点是可以不用回表，但是太占地方了呀～相当于每建立一棵B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。因为这种按照非主键列建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为二级索引（英文名secondary index），或者辅助索引。由于我们使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树为为c2列建立的索引。

联合索引：基准多个属性，先排一个，再排一个。千万要注意一点，以c2和c3列的大小为排序规则建立的B+树称为联合索引，它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：
    1、建立联合索引只会建立如上图一样的1棵B+树。
    2、为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。

一个B+树索引的根节点自诞生之日起，便不会再移动。根节点先是存储普通数据记录，当可用空间用完后全部内容被复制到一个新页并进行页分裂（得到新页a和新页b），而根节点便升级为存储目录项记录的页。


————————Java：
引用没有指向后就被回收了
static字段只会有一个，多个引用只会指向那一个，要是连类都是是静态的话就没有引用了，直接用类名调用它。即使类不是静态也可以通过类名引用静态字段。
java.lang默认导入
javadoc还不会用。
==比的事这个地址下存的东西，但实际上只有基础类型才直接存值；.equal才会比这个地址存的引用引用的内容。
逻辑表达的短路：逻辑表达式已经能得出结论时，后面的不再计算。
跳过了位操作符
构造器无返回值，但new表达式会返回一个新建对象的引用
根据变量区分重载函数
this相当于上一个对象引用被传进所调用的方法了。
this连续两次构造的关键点在于参数数量是在不断减少的所以默认构造器只会最后才出现。
static的另一层含义：static静态方法是没有this的，所以它不能调用非静态方法（因为非静态方法要默认传一个this，代替当前实例对象的引用，而static方法没有this）当然如果手动传一个实例对象引用就可以了。
垃圾回收机制的finalize()方法。
finalize()方法似乎是在对象被回收时被调用的，还可以加判断来判定回收条件是否符合。
java的垃圾回收器使得它在堆中不必去找哪些空闲内存块，它会在回收空间的同时使堆中已经存在的对象紧密排列，实现高速且有无限空间分配的堆模型，速度接近堆栈上分配空间的速度。
引用离开作用域或被置为null，对象的“引用计数”减1；但实际上是从堆栈和静态存储区之中的引用开始遍历找出所有“活”的对象。先从这个引用开始找到对应的实例对象，然而找到这个对象包含的其它的所有引用，不断重复，直到所有网络都被访问为止。“死”的对象不访问。
自适应垃圾回收技术的一种做法是停止_复制：先暂停程序的运行，把活对象从当前堆复制到另一个堆，没有被复制的都是垃圾。同时新堆被复制后是一个接一个紧凑排列的。
自适应垃圾回收技术的另一种工作模式是标记_清扫：同样从堆栈和静态存储区中出发，但只给存活对象设置标记，不回收。全部标记完成后，将没被标记的释放掉，不复制。因此剩下的空间不连续。
自适应的分块排列以及每个块有代数，引用就加1，废弃块会被放入新对象。
即时编译器技术（Just-In-Time,JIT）弄成本地机器码，代码被执行的次数越多，它的速度就越快。类加载器在成功加载某个类之后，会把得到的 java.lang.Class类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。
类的字段会比类先初始化（比该类的构造函数还先调用）
可变参数列表：Object... obj，这里可以接受多个不限类型的参数。
public static void main(String[] args)是每个class的执行入口，没有这个入口就无法方便地单元测试。同时java xxx就相当于xxx.main()了，即使xxx不是public也可以。
类独立于文件，依靠Package路径的java命令调用！

正在播放 《你是魔鬼吗》 ━━━━━━─────── 3:47 ⇆ ◁ ❚❚ ▷ ↻

private修饰的属性或方法为该类所特有，在任何其他类中都不能直接访问；
default修饰的属性或方法具有包访问特性，同一个包中的其他类可以访问；
protected修饰的属性或方法在同一个中的其他类可以访问，同时对于不在同一个包中的子类中也可以访问；
public修饰的属性或方法外部类中都可以直接访问。
当子类继承父类，子类可以继承父类中具有访问控制权限的属性和方法（一般来说是非private修饰的），对于private修饰的父类所特有的属性和方法，子类是不继承过来的。
当子类需要改变继承过来的方法时，也就是常说的重写父类的方法。一旦重写后，父类的此方法对子类来说表现为隐藏。以后子类的对象调用此方法时，都是调用子类重写后
的方法，但子类对象中想调用父类原来的此方法时，可以通过如下两种方式：
1.将子类对象类型强制转化为父类类型，进行调用；
2.通过super调用。
同样的，如果在子类中定义父类中相同名称的属性时，父类属性在子类中表现为隐藏

因此public ,protected, private区别就只有类与类之间的关系了。类内，类继承间，类与类外。文件只是载体，具体通过本身的类名与package路径组成的全名加以区分。
继承：从最初父类开始的构造，可用它们的public/protected方法与字段。
super(xxx)方法一般用于父类只有含参构造器而没有实现默认构造器时在子类构造器中第一行使用。
final字段避免被修改，final方法避免继承中被重写或重载，final类避免被继承。
通过上转型和后期的动态绑定来实现多态，先实例化一个对象赋给基类引用（动态绑定），覆盖方法后会根据相应的类型来调用相应的方法(表面上表现为使用基类引用去表示子类实例对象去调用方法，基类方法根据子类的类型执行不同的操作)。
字段是基类的，方法可以动态绑定至导出类所覆盖的方法上。

正在播放 《你是魔鬼吗》 ━━━━━━─────── 3:47 ⇆ ◁ ❚❚ ▷ ↻

容器的如果不带尖括号说明类型就直接是Object类型了，下次取用要强制转换。
容器本身就是泛型
Collection<class>
Collections.addAll()很快，首先方式
.iterator()返回一个迭代器对象，用Iterator<class> 引用接住它。
异常被抛出后将在别的地方被处理
System.out.print()与System.out.format()用法一样，形式上与C语言的printf()相同。
Java正则表达式：“？”表示上一个是可能有，“+”表示上一个是可能有很多。
多态与容器组合测试我还不会？
List容器将对象作为Object对象存储吗，取出时再转回去吗。
任务作为进程在自己的地址空间中运行。
Thread构造器的start方法调用后将开启一个新线程运行任务，之后start方法立即返回，继续本线程的执行。
Thread构造器的yield方法声明可以切换给其他任务了。
多线程的异常不能跨线程传回去，必须在此线程内处理。
start之前(Thread).setDaemon(true)可置为后台线程。后台线程无法阻止程序关闭，必须由非后台线程（比如main()）来维持程序的持续运转。
ExecutorService的shutdown方法用于终止线程（如果不中止它就一直在运行，就停不下来了。）
一旦被继承，子类就可以自己调用所有父类的非私有变量及方法了。（比如继承自Thread类的子类可以变得跟Thread类实例对象一样用自己的实例对象调用.start()方法实现多线程。）
异步方式实现多线程：ExecutorService创建一个实例对象接住Executors的线程池方法，之后可用这个实例对象调用execute()方法执行异步方式的多线程，最后要使用exec.shutdown();否则停不下来。它对封装好的多线程体没有特殊要求，与调用.start()方法一样，但比start()方法更加安全。


正在播放 《你是魔鬼吗》 ━━━━━━─────── 3:47 ⇆ ◁ ❚❚ ▷ ↻


StringBuffer的.append(str)方法代替String的“+”连接，速度更快一些。
String str = new String("1")创建于堆中，intern()方法会建在字符串常量池里有个记录，而String str1 = "1"优先于字符串常量池中查找对象并返回。内存空间地址。如果常量池中没有，就在堆中生成对象，同时在常量池中生成一个引用。字符串常量池只存储引用，不存储内容。那么比如String a = "Hello Wolrd"中的Hello Wolrd是保存在堆中的对象里。
栈里的实例对象引用或者字符引用指向堆中的对象或者常量池中的常量



子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的一些属性或方法。
类的初始化不同于类实例对象的初始化，类的初始化只有一次，当对同一个类new多个对象时，类属性和类初始化块只初始化一次。类属性和代码块顺序决定了初始化的顺序（代码块是就仅被｛｝包含的代码块，但这句话是什么意思？与类属性在一起的明显是静态(static)代码块，而且静态(static)代码块必然在类属性的后面；并且类在通过new创建实例对象时必然是先调用代码块再调用构造器），若类存在父类，则首先初始化父类的类属性和类初始化块，一直上溯到Object类最先执行。————到这里，这个类就算是在JVM里装载完成了。接下来就在main()方法入口里面等着用new来调用创建实例对象了。在new创建对象时，首先对对象属性和初始化块分配内存，并执行默认初始化（这里应该注意：即使实现并调用了含参构造器，也会默认先调用无参的默认构造器！）。如果存在父类，则先为父类对象属和初始化块先分配内存并执行初始化。然后执行父类构造器中的初始化程序，接着才开始对子类的对象属性和初始化块执行初始化。
(下面的我还有点不熟)
4.继承中的this和super：
构造器中的this表示当前正在初始化的对象引用，方法中的this表示当前正在调用此方法的对象引用。this具体用法表现在以下几个方面：
1.当具多个重载的构造器时，且一个构造器需要调用另外一个构造器，在其第一行使用this（param）形式调用，且只能在第一行；
2.当对象中一个方法需要调用本对象中其他方法时，使用this作为主调，也可以不写，实际上默认就是this作为主调；
3.当对象属性和方法中的局部变量名称相同时，在该方法中需要显式的使用this作为主调，以表示对象的属性，若不存在此问题，可以不显式的写this。（比如下面的例子）
int param;
function abc(string param){
    this.param=param
}

其实，其牵涉到的一个问题就是变量的查找规则：先局部变量 => 当前类中定义的变量 => 其父类中定义的可以被子类继承的变量 => 父类...
super表示调用父类中相应的属性和方法。在方法中，若需要调用父类的方法时，也一定要写在第一行
(下面的我还有点不熟)
5. 继承与组合：
从单纯的实现效果上看，继承和组合都能达到同样的目的。并且都是实现代码复用的有效方式。
但在一般性的概念层次中，两者具有较为明显的差别。
继承表现为一般——特殊的关系，子类是一个特殊的父类，是is-a的关系。父类具有所有子类的一般特性。
组合表现为整体——部分关系，即has-a关系。在组合中，通过将“部分”单独抽取出来，形成自己的类定义，并且在“整体”
这个类定义中，将部分定义为其中的一个属性，并通过get和set方法，以此可以调用“部分”类中的属性和方法。


这是试验理解：
1、每一个类的静态(static)代码块都只会在往JVM中装载时执行且只执行一次！
2、声明一个继承自父类的子类时，先把父类的构造代码块及构造方法初始化然后初始化子类的构造代码块和构造方法。
3、构造代码块先于构造方法！

正在播放 《你是魔鬼吗》 ━━━━━━─────── 3:47 ⇆ ◁ ❚❚ ▷ ↻

YGC ：对新生代堆进行gc。频率比较高，因为大部分对象的存活寿命较短，在新生代里被回收。性能耗费较小。
FGC ：全堆范围的gc。默认堆空间使用到达80%(可调整)的时候会触发fgc。以我们生产环境为例，一般比较少会触发fgc，有时10天或一周左右会有一次。
什么时候执行YGC和FGC:
1、a.eden空间不足,执行 young gc
2、b.old空间不足，perm空间不足，调用方法System.gc() ，ygc时的悲观策略, dump live的内存信息时(jmap –dump:live)，都会执行full gc

正在播放 《你是魔鬼吗》 ━━━━━━─────── 3:47 ⇆ ◁ ❚❚ ▷ ↻

long l_starttime = System.nanoTime();
long l_endtime = System.nanoTime();
System.out.println("运行时间为:" + (l_endtime - l_starttime) + "us");

正在播放 《你是魔鬼吗》 ━━━━━━─────── 3:47 ⇆ ◁ ❚❚ ▷ ↻

  排序a数组：
	public static void sort(Object[] a)
  a数组二分找key，先排序：
  	public static int binarySearch(Object[] a, Object key)

    Arrays.sort(t1.nn_exp);
    System.out.println(Arrays.binarySearch(t1.nn_exp, 44));

    用val填a数组：
    	public static void fill(int[] a, int val)
        完全相同比较数组：
        	public static boolean equals(Object[] a, Object[] a2)

正在播放 《你是魔鬼吗》 ━━━━━━─────── 3:47 ⇆ ◁ ❚❚ ▷ ↻

List<Integer> list_n = new ArrayList<>();

list_n.add(1);
list_n.add(2);

System.out.println(list_n);
list_n.clear();
System.out.println(list_n);
list_n.add(8);
list_n.add(8);
System.out.println(list_n);


正在播放 《你是魔鬼吗》 ━━━━━━─────── 3:47 ⇆ ◁ ❚❚ ▷ ↻
List列表被删除一个元素后将自动前压。

正在播放 《你是魔鬼吗》 ━━━━━━─────── 3:47 ⇆ ◁ ❚❚ ▷ ↻
在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。

浅拷贝:拷贝对象和原始对象的引用类型引用同一个对象。
浅拷贝:拷贝对象和原始对象的引用类型引用不同对象。

正在播放 《你是魔鬼吗》 ━━━━━━─────── 3:47 ⇆ ◁ ❚❚ ▷ ↻

静态内部类：非静态内部类依赖于外部类的实例，而静态内部类不需要。静态内部类不能访问外部类的非静态的变量和方法。

反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。

Java 与 C++ 的区别：
Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。
Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。
Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。
Java 支持自动垃圾回收，而 C++ 需要手动回收。
Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。
Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。
Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。
Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。



正在播放 《你是魔鬼吗》 ━━━━━━─────── 3:47 ⇆ ◁ ❚❚ ▷ ↻